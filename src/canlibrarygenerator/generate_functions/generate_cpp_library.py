from collections import defaultdict
from datetime import datetime
from typing import Union

def _generate_file_header_comment(file_name, brief_description):
    """Generates the Doxygen header comment."""
    current_date = datetime.now().strftime("%d.%m.%Y")
    current_year = datetime.now().year

    comment = f"""/*******************************************************************************
*
* @file         {file_name}
* @brief        {brief_description}
* @author       Generated using CAN Library Generator tool
* @date         {current_date}
*
* @copyright    (c) {current_year} Mobility Lab, VÅ B - Technical University of Ostrava
* All rights reserved.
*
* @details      This file was automatically generated by CAN Library Generator tool.
* Contains definitions and/or implementations of functions for working with CAN messages.
* Any manual modifications in this file will be overwritten
* during subsequent generation.
*
******************************************************************************/

/**
 * @file {file_name}
 * @brief Defines the core structures and functions for CAN communication.
 */
\n"""
    return comment

def _generate_function_doxygen_comment(function_name, params, return_type, brief="", details: Union[str, dict] = ""):
    """Generates a Doxygen comment block for a function."""
    comment = f"/**\n * @brief   {brief}\n *\n"
    for param_name, param_desc in params:
        comment += f" * @param   {param_name} {param_desc}\n"
    if return_type and return_type != "void" and return_type != "bool":
        comment += f" * @return  {return_type} {details}\n"
    elif return_type == "bool":
         comment += f" * @retval  true {details.get('true', 'Success.')}\n"
         comment += f" * @retval  false {details.get('false', 'Error.')}\n"
    elif details and not isinstance(details, dict):
        comment += f" * @details {details}\n"

    comment += " */\n"
    return comment

def generate_cpp_code(selected_items, library_name, dbs, tree):
    """Generate C++ code for selected messages and signals."""
    # Group selected messages and signals
    selected_messages = defaultdict(list)  # Dictionary to store selected messages and their signals
    for item in selected_items:
        item_type = tree.item(item, "values")[0]
        if item_type == "Message":
            message_name = tree.item(item, "text")
            selected_messages[message_name] = []  # Select all signals if the message is selected
        elif item_type == "Signal":
            parent = tree.parent(item)
            message_name = tree.item(parent, "text")
            signal_name = tree.item(item, "text")
            selected_messages[message_name].append(signal_name)

    # ---------- .hpp file ----------

    # Generate C++ header file (.hpp)
    hpp_code = _generate_file_header_comment(
        f"{library_name}.hpp",
        f"Definitions of structures and functions for CAN communication"
    )
    hpp_code += f"#ifndef {library_name.upper()}_HPP\n"
    hpp_code += f"#define {library_name.upper()}_HPP\n\n"
    hpp_code += "#include <cstring>\n"
    hpp_code += "#include <vector>\n"
    hpp_code += "#include <cstdint>\n"
    hpp_code += "#include <iostream>\n\n"

    # Define the DBCSignal structure
    hpp_code += "/**\n * @brief   Structure representing a CAN signal.\n */\n"
    hpp_code += "struct DBCSignal {\n"
    hpp_code += "    const std::string name;\n"
    hpp_code += "    uint16_t startBit;\n"
    hpp_code += "    uint8_t length;\n"
    hpp_code += "    const std::string byteOrder;\n"
    hpp_code += "    char valueType;\n"
    hpp_code += "    double factor;\n"
    hpp_code += "    double offset;\n"
    hpp_code += "    double min;\n"
    hpp_code += "    double max;\n"
    hpp_code += "    const std::string unit;\n"
    hpp_code += "    const std::string receiver;\n"
    hpp_code += "    uint64_t raw_value = 0;\n"
    hpp_code += "    double value = 0.0;\n"
    hpp_code += "\n"
    hpp_code += "    /**\n     * @brief   Constructor for initializing a DBCSignal.\n"
    hpp_code += "     *\n"
    hpp_code += "     * @param   n Name of the signal.\n"
    hpp_code += "     * @param   start Start bit of the signal.\n"
    hpp_code += "     * @param   len Length of the signal in bits.\n"
    hpp_code += "     * @param   byteOrder Byte order (\"little_endian\"/\"big_endian\").\n"
    hpp_code += "     * @param   valueType Value type ('s' for signed, 'u' for unsigned).\n"
    hpp_code += "     * @param   factor Factor for conversion to physical value.\n"
    hpp_code += "     * @param   offset Offset for conversion to physical value.\n"
    hpp_code += "     * @param   min Minimum physical value (default 0.0).\n"
    hpp_code += "     * @param   max Maximum physical value (default 0.0).\n"
    hpp_code += "     * @param   unit Unit of the signal (default empty string).\n"
    hpp_code += "     * @param   receiver Receiver of the signal (default empty string).\n"
    hpp_code += "     */\n"
    hpp_code += "    DBCSignal(std::string n, uint16_t start, uint8_t len, std::string byteOrder, char valueType, "
    hpp_code += "double factor, double offset, double min = 0.0, double max = 0.0, "
    hpp_code += "std::string unit = \"\", std::string receiver = \"\")\n"
    hpp_code += "        : name(n), startBit(start), length(len), byteOrder(byteOrder), valueType(valueType), "
    hpp_code += "factor(factor), offset(offset), min(min), max(max), unit(unit), receiver(receiver), raw_value(0), value(0.0) {}\n"
    hpp_code += "};\n\n"

    # Define the DBCMessageBase structure
    hpp_code += "/**\n * @brief   Base structure for a CAN message.\n */\n"
    hpp_code += "struct DBCMessageBase {\n"
    hpp_code += "    uint32_t id;\n"
    hpp_code += "    const std::string name;\n"
    hpp_code += "    uint8_t dlc;\n"
    hpp_code += "    const std::string sender;\n"
    hpp_code += "    uint8_t data[64]{};\n"
    hpp_code += "    bool is_fd;\n"
    hpp_code += "    std::vector<DBCSignal*> signals;\n"
    hpp_code += "};\n\n"

    # Generate unique struct for each message
    for message_name, signal_names in selected_messages.items():
        message = None
        for db in dbs:
            try:
                message = db.get_message_by_name(message_name)
                break
            except KeyError:
                continue
        if not message:
            continue

        struct_name = f"DBCMessage_{message_name.replace(' ', '')}"
        hpp_code += f"// Structure for CAN message '{message_name}'.\n"
        hpp_code += f"struct {struct_name} {{\n"
        hpp_code += "    DBCMessageBase base;\n"

        # Add direct signal pointers
        for signal in message.signals:
            if not signal_names or signal.name in signal_names:
                hpp_code += f"    DBCSignal *{signal.name};\n"

        hpp_code += "};\n\n"

    # Declare messages in the header file as extern
    hpp_code += "// Declaration of global CAN message instances.\n"
    for message_name in selected_messages:
        struct_name = f"DBCMessage_{message_name.replace(' ', '')}"
        hpp_code += f"extern {struct_name} {message_name};\n"

    # Message registry
    hpp_code += "// Global registry of all defined CAN messages.\n"
    hpp_code += "extern std::vector<DBCMessageBase*> dbc_all_messages;\n\n"

    # Function declaration with Doxygen comments
    hpp_code += "// Functions\n"
    hpp_code += _generate_function_doxygen_comment(
        "dbc_find_message_by_id",
        [("can_id", "The CAN ID of the message to find.")],
        "DBCMessageBase*",
        brief="Finds a CAN message in the registry by its ID.",
        details="Returns a pointer to the found message or `nullptr` if the message was not found."
    )
    hpp_code += "DBCMessageBase* dbc_find_message_by_id(uint32_t can_id);\n"

    hpp_code += _generate_function_doxygen_comment(
        "dbc_parse_signal",
        [("data", "Pointer to the array of CAN data bytes."),
         ("dlc", "Data Length Code (DLC) of the received message."),
         ("startBit", "Start bit of the signal."),
         ("length", "Length of the signal in bits."),
         ("byteOrder", "String specifying byte order (\"little_endian\" or \"big_endian\").")],
        "uint64_t",
        brief="Parses the raw signal value from CAN data.",
        details="Extracts signal bits from the data array according to the specified start bit, length, and byte order."
    )
    hpp_code += "uint64_t dbc_parse_signal(const uint8_t* data, uint8_t dlc, uint16_t startBit, uint8_t length, std::string byteOrder);\n"

    hpp_code += _generate_function_doxygen_comment(
        "dbc_unpackage_message",
        [("can_id", "CAN ID of the received message."),
         ("data", "Pointer to the array of received CAN data bytes."),
         ("dlc", "Data Length Code (DLC) of the received message.")],
        "bool",
        brief="Unpackages a received CAN message and updates signal values.",
        details={"true": "Message was successfully unpackaged.", "false": "Message not found or DLC mismatch."}
    )
    hpp_code += "bool dbc_unpackage_message(uint32_t can_id, const uint8_t* data, uint8_t dlc);\n"

    hpp_code += _generate_function_doxygen_comment(
        "dbc_insert_signal",
        [("data", "Pointer to the byte array where the signal should be inserted."),
         ("dlc", "Data Length Code (DLC) of the received message."),
         ("raw_value", "Raw signal value to insert."),
         ("startBit", "Start bit of the signal."),
         ("length", "Length of the signal in bits."),
         ("byteOrder", "String specifying byte order (\"little_endian\" or \"big_endian\").")],
        "void",
        brief="Inserts the raw signal value into a CAN data byte array.",
        details="Writes the bits of the raw signal value into the data array according to the specified start bit, length, and byte order."
    )
    hpp_code += "void dbc_insert_signal(uint8_t* data, uint8_t dlc, uint32_t raw_value, uint16_t startBit, uint8_t length, std::string byteOrder);\n"

    hpp_code += _generate_function_doxygen_comment(
        "dbc_package_message",
        [("can_id", "CAN ID of the message to package.")],
        "bool",
        brief="Packages CAN message signals into a data array for transmission.",
        details={"true": "Message was successfully packaged.", "false": "Message not found or DLC mismatch."}
    )
    hpp_code += "bool dbc_package_message(uint32_t can_id);\n"

    hpp_code += f"\n#endif // {library_name.upper()}_HPP\n"

    # ---------- .cpp file ----------

    # Generate C++ implementation file (.cpp)
    cpp_code = _generate_file_header_comment(
        f"{library_name}.cpp",
        f"Implementation of functions for CAN communication"
    )
    cpp_code += f'#include "{library_name}.hpp"\n\n'

    # Define messages in the implementation file
    cpp_code += "// ---------------- Signal definitions ----------------\n\n"

    for message_name, signal_names in selected_messages.items():
        # Find the message in the loaded databases
        message = None
        for db in dbs:
            try:
                message = db.get_message_by_name(message_name)
                break
            except KeyError:
                continue

        if not message:
            continue  # Skip if the message is not found

        cpp_code += f"// {message_name} signals\n"
        for signal in message.signals:
            if not signal_names or signal.name in signal_names:  # Add only selected signals
                min_value = signal.minimum if signal.minimum is not None else 0.0
                max_value = signal.maximum if signal.maximum is not None else 0.0

                cpp_code += (
                    f"static DBCSignal {signal.name}(\"{signal.name}\", {signal.start}, {signal.length}, \"{'big_endian' if signal.byte_order == 'big_endian' else 'little_endian'}\","
                    f"'{'s' if signal.is_signed else 'u'}', {signal.scale}, {signal.offset}, {min_value}, {max_value}, \"{signal.unit}\", "
                    f"\"{', '.join(signal.receivers) if signal.receivers else 'None'}\");\n")

        cpp_code += "// ---------------- Message definitions ----------------\n\n"

        struct_name = f"DBCMessage_{message_name.replace(' ', '')}"
        is_fd = "true" if message.is_fd else "false"
        cpp_code += f"// Message {message_name}\n"

        cpp_code += f"{struct_name} {message.name} = {{\n"
        cpp_code += "    {\n"
        cpp_code += f"        {message.frame_id},\n"
        cpp_code += f"        \"{message.name}\",\n"
        cpp_code += f"        {message.length},\n"
        cpp_code += f"        \"{message.senders[0] if message.senders else ''}\",\n"
        cpp_code += "        {0},\n"
        cpp_code += f"        {is_fd},\n"
        cpp_code += "        {\n"

        for signal in message.signals:
            cpp_code += f"            &{signal.name},\n"

        cpp_code += "        }\n"
        cpp_code += "    },\n"

        for signal in message.signals:
            cpp_code += f"    &{signal.name},\n"

        cpp_code += "};\n\n"

    # Message registry
    cpp_code += "// ---------------- Message registry ----------------\n\n"
    cpp_code += "std::vector<DBCMessageBase*> dbc_all_messages = {\n"
    for message_name in selected_messages:
        cpp_code += f"    &{message_name}.base,\n"
    cpp_code += "};\n\n"

    # Functions
    cpp_code += "// ---------------- Functions ----------------\n\n"
    # Find a message by ID function
    cpp_code += """DBCMessageBase* dbc_find_message_by_id(const uint32_t can_id) {
    for (auto* msg : dbc_all_messages) {
        if (msg->id == can_id) {
            return msg;
        }
    }
    return nullptr;
}\n\n"""

    # Parse signal function
    cpp_code += """// Parse signal function
uint64_t dbc_parse_signal(const uint8_t* data, const uint8_t dlc, const uint16_t startBit, const uint8_t length, const std::string byteOrder) {
    uint64_t result = 0;
    
    if (byteOrder == "little_endian") {
        int byteIndex = startBit / 8;
        int bitIndex = startBit % 8;
        int bitsLeft = length;
        int shift = 0;
        
        while (bitsLeft > 0 && byteIndex < dlc) {
            uint8_t byte = data[byteIndex];
            int bitsInThisByte = std::min(bitsLeft, 8 - bitIndex);
            uint8_t mask = ((1 << bitsInThisByte) - 1) << bitIndex;
            uint8_t bits = (byte & mask) >> bitIndex;
            result |= (bits << shift);
            
            bitsLeft -= bitsInThisByte;
            shift += bitsInThisByte;
            byteIndex++;
            bitIndex = 0;
        }
    } else {
        for (int i = 0; i < length; ++i) {
            int bitPos = startBit - i;
            int byteIndex = bitPos / 8;
            int bitIndex = bitPos % 8;
            if (byteIndex >= dlc) continue;
            uint8_t bit = (data[byteIndex] >> (7 - bitIndex)) & 0x1;
            result = (result << 1) | bit;
        }
    }
    
    return result;
}\n\n"""

    # Unpackage message function
    cpp_code += """// Unpackage message function
bool dbc_unpackage_message(const uint32_t can_id, const uint8_t* data, const uint8_t dlc) {
    DBCMessageBase* msg = dbc_find_message_by_id(can_id);
    
    if (!msg || msg->dlc != dlc) {
        std::cout << "Message not found or DLC mismatch!" << std::endl;
        return false;
    }
    
    std::cout << "Message found!" << std::endl;
    std::memcpy(msg->data, data, msg->dlc);

    for (auto* sig : msg->signals) {
        uint64_t raw = dbc_parse_signal(msg->data, msg->dlc, sig->startBit, sig->length, sig->byteOrder);
        sig->raw_value = raw;
        
        if (sig->valueType == 's') {
            auto signed_val = static_cast<int64_t>(raw);
            int shift = 64 - sig->length;
            signed_val = (signed_val << shift) >> shift;  // sign-extend
            sig->value = signed_val * sig->factor + sig->offset;
        } else {
            sig->value = raw * sig->factor + sig->offset;
        }
    }

    return true;
}\n\n"""

    # Insert signal data function
    cpp_code += """// Insert signal data function
void dbc_insert_signal(uint8_t* data, const uint8_t dlc, const uint32_t raw_value, const uint16_t startBit, const uint8_t length, const std::string byteOrder) {
    if (byteOrder == "little_endian") {
        for(int i = 0; i < length; ++i) {
            int bitIndex = startBit + i;
            int byteIndex = bitIndex / 8;
            int bit_in_byte = bitIndex % 8;
            if (byteIndex >= dlc) continue;
            
            if ((raw_value >> i) & 1) {
                data[byteIndex] |= (1 << bit_in_byte);
            } else {
                data[byteIndex] &= ~(1 << bit_in_byte);
            }
        }
    } else {
        for (int i = 0; i < length; ++i) {
            int bitPos = startBit - i;
            int byteIndex = bitPos / 8;
            int bitIndex = bitPos % 8;
            if (byteIndex >= dlc) continue;
            
            if ((raw_value >> i) & 1) {
                data[byteIndex] |= (1 << (7 - bitIndex));
            } else {
                data[byteIndex] &= ~(1 << (7 - bitIndex));
            }
        }
    }
}\n\n"""

    # Package message function
    cpp_code += """// Package message function
bool dbc_package_message(const uint32_t can_id) {
    DBCMessageBase* msg = dbc_find_message_by_id(can_id);
    
    std::cout << "Message found!" << std::endl;
    std::memset(msg->data, 0, msg->dlc);

    for (auto* sig : msg->signals) {
        dbc_insert_signal(msg->data, msg->dlc, sig->raw_value, sig->startBit, sig->length, sig->byteOrder);
    }

    return true;
}"""

    return hpp_code, cpp_code